#コメント消して見やすくできるが、あえてこのまま.pyにして保存。勉強になった！

h,w,n = map(int,input().split())

#二次元配列にこのゲームのマップを格納
game_zu=[]
for f in range(h):
    game_zu.append(["."]*w)

"""初期化メソッドでの定義、class外部からのグローバルオブジェクトの引用、for文内での変数定義、クラス変数定義
        self.x_i,w_i,h_i                   game_zu[][]                         level,a        count,irekae_dan

        ⇒kこんがらがりがちの【スコープ】について。全てためした。　出たエラーの意味も必ず理解する。
"""
class Gamemap:
        #クラス変数定義
        count = 0
        irekae_dan = h-1
        
        #初期化メソッド
        def __init__(self,h_i,w_i,x_i):
            #ここでマップを作成したら、Gamemapを使って作成したインスタンスを書くたびに、
            # 読み込まれてしまうのでNG.　おｋ         
            self.h_i = h_i 
            self.w_i = w_i
            self.x_i = x_i
            self.count = 0#ここで0入れることも、できる。countを入れたらエラー

        #渡されたブロックがどこまで落ちるかの処理 高さh-1-0が最下層。
        def rakka_indent(self):
        
            #縦段分、横の列比べを繰り返す。
            #見やすくするため変数1文字で収まるよう、rangeの書き方変えてみる試み

            for level in range(0,h):#　（h_i）  ≒ （0 , h_i-1）

                #横幅をそれぞれ試す (w_i回)
                for a in range(x_i,x_i+w_i):
                    if game_zu[level][a] == "#":
                        #この時の「段の1個上分」のインデックスを変数に入れて記録。
                        self.irekae_dan = level-1
                        self.count += 1
                        #print(level,a)#確認用,エラー修正に大活躍
                        break
                #「#ある段」が最初に見つかった時点で、二重for抜けるための処理
                #結局これにcount 使用した
                if self.count !=0:
                    break

            #print(self.irekae_dan)#エラー修正に大活躍
            
        #w_i,h_i分「.」⇒「#」変換メソッド
        def okikae(self):
            #高さがこうじゃない！！:例えば4段目から4blockあるなら、[上には―1の３つ]あがる
            #そして、第2引数の値までしかカウントされない。　つまり・・
            for b in range(self.irekae_dan,self.irekae_dan -h_i -1 +1 ,-1):
            #　↑★ここの-1と+1を消したら、意味合い的におかしくなる↑
                for c in range(x_i,x_i+w_i):
                    game_zu[b][c] = "#"

#ブロック個数分、繰り返す
for d in range(n):
    h_i, w_i, x_i = map(int,input().split())

    #入力される度にオブジェクト（インスタンス）生成
    block = Gamemap(h_i,w_i,x_i)
    # ↓ この関数に個別に取らせる引数はない。（ 勇者と炎放つ魔法使いの、paizaでやったな。）
    block.rakka_indent()
    block.okikae()
    
for e in range(h):
    ans ="".join(game_zu[e])
    print(ans)
            
#print(str(d+2)+"回目")#確認用

"""
他、VSCodeに消し去った備忘録

class Gamemap:
        def __init_(self):
            #ここでマップを作成したら、Gamemapを使って作成したインスタンスを書くたびに、
            # 読み込まれてしまうのでNG.　おｋ         

        #渡されたブロックが落ちないかの処理 高さh-1-0が最下層。
        def block_rakka(self):
            #x_i＋１個目に、ブロックの左端がくるからリストのインデックスとして見立てると[x_i-1+1]
            #ただ最下層の左が＃じゃなくても、すでに最下層の⇒側が＃で上に乗るケースもある。
            #だから、（★前ココがややこしくてリタイアしたんだが）
            #最下層のx_i個目、っていうより、　最下層で★w_i回文loopする文で、
            #[x_i]～[x_i + w_i - 1]まで　　★★0 ～ w_i-1 を変数にいれるfor文にして
            # リストインデックスの指定を行う。

            #よってブロックの横幅分、そのx座標、その時点での最下層が＃になってないか順に比べ、
            #なっている段階で段を一つ上げ（level－１）、同じ処理をまた行う。
            #⇒これで、すべての横幅において「.」が確認された場合（count==w_i）
            #その高さからのh_i-1段上まで（合計 h_i段）、文字の置き換えをまた二重for文で行う。
            #★★ー0から ー（h_i-1）までの、★これもまたh_i回loopする文で、
            #★  　　　　　　↑を変数に入れるfor文を作る。
            
            #となると、一番下の段から順に落ちる位置（x_i）からの【全ての横幅（w_i）】試してって
            # "#"みつけた瞬間　横一列試すfor文をbreakしてぬけて、次の段を行っていく。
            #　"#"みつけた瞬間、　countも0に戻す。 　　X●　←↑これはダメ！バグる　→いやバグらない
            #                           奥に落とすのに手前に.あるとやめちゃう⇒x_i飛ばすから平気
            #最後まで試して、一致したときじゃないと。

            # count がw_iと同じ（全幅＝"."と判定できた段の処理がおわってその処理に到達した）時、
            #　そこから関数を呼び出す。
            #　その関数は、その指定された高さ(game_zu[●][]　←丸に入る変数、★これを保持しておくこと！！)
            # から「h_i-1」上の高さまで、★★ 「w_i」回 .を#にする処理を「h_i」回行う二重構文をまた書く。

            #そして上の処理を、ブロックの個数ｎ回数分。
            #読みにくくなるのを避けるため、上の二重構文の処理を、forで呼び出す感じがいいな。
            #　3重は避けたい。

            #　んで落とすブロックの入力打ちを受け取ってからの　defの処理で、
            # 始めにどの段からやるか、なんだが　
            # ●●効率は悪いだろうが、例え4段３が積み重ねってても　最下段からやるプログラムのほうが
            #思いつきいやすい。　4段積み重なってる隣は1段も積み重なってないかもしれなくって、

            #　★！思いつくのは、一番上の段から#が出るましたにしたに試してく方法だが
            #　やり方は違うが、俯瞰してみると　かかる手間は同じだ。

            #てことは綺麗に書けても総当たりか。　もっと効率のいいやり方ねーのかよォ！！


            #↑これで完成、なのか・・？ 　☆こりゃ確かに、アレンジで練習する意味が分かったわ。１からは大変
            #オブジェクト指向的な「設計図」はかけた。　あとは、これに沿って
            #               関数定義しつつ、　進むだけだ。。　
            #つっても、forの中で行うコードが短いんなら、defするまでもねぇんだが。

            #落とせるか確認の関数と、「.」をブロック分の「＃」に書き換える関数。の２つ、そしてそれをnブロック分
            #落ち場所を探す二重for構文と、その高さから書き換える二重for構文の2つ必要。

            #どうする・・？下から試してるから、上にあった場合の乗っかりを、検知できないｗｗｗｗ
            #完全に予想外だったよ  くそう、あとちょっとなのに。
            for e in range(h):
                #terasリストには、#のあるlistが入る。
                teras = ([i for i, x in enumerate(game_zu[e]) if x == '#'])
                # #があった場合そこを上書きして記録、
                if len(teras) > 0:
                #　#がなかった場合一番下へ行かす。。
                else:
                #いやダメだ、↑のじゃあw_i分だけ測定するのは不可能だ。なら仕方ない！

                #初めに思いついてた、「count2」をつかおう。　これしかやり方思いつかなくて悔しいけど。


            if game_zu[h-1-level][x_i-1+1] == "."


"""
